[TOC]

# http服务及IO事件模型讲解

一次http事物，由一个请求报文和一个响应报文组成

请求报文request的组成：

> <method><URL><VERSION>：请求方法：请求资源的URL：协议版本
>
> HEADERS： 每一个headers 由name：value组成
>
> <body>：主体部分，根据请求方法，主体部分可能为空

响应报文response的组成：

> <VERSION><STATUS><REASON_PHRASE>：版本：响应码：原因短语
>
> HEADERS：由name：value组成
>
> <body>：主体部分，根据响应码，主体内容也不同

请求方法method

> GET：请求获取资源
>
> HEAD：请求资源，但只希望获得其头部数据
>
> POST：请求表单
>
> PUT：上传文件
>
> DELETE：删除文件
>
> TRACES：追踪经过的所有代理服务器
>
> OPTIONS：获取一个资源允许的请求方法的列表

响应码：

> 1xx：没什么关键性的意义
>
> 2xx：成功类响应码：200
>
> 3xx：重定向类的响应码，301,302,304
>
> 4xx：客户端错误，403,404
>
> 5xx：服务器端错误，502

认证：

基于ip认证

基于用户认证：basic、digest（这些都是协议认证，但是大多网站都是基于表单认证，而非协议认证）

httpd MPM：

prefork：进程模型，两级结构，主进程master负责生成子进程，每个子进程负责响应一个请求

worker：线程模型，三级结构，主进程master负责生成多个子进程，每个子进程负责生成多个线程，每个线程响应一个请求；

event：主进程master负责生成子进程，每个子进程响应多个请求；

I/O模型：阻塞型，非阻塞型，复用型，型号驱动型，异步

同步/异步：关注消息通知机制

>  同步：等待对方返回消息
>
> 异步：被调用者通过状态，通知或回调机制，通知调用者被盗用着的运行状态

阻塞/非阻塞：关注调用者在等待结果返回之前所处的状态

> 阻塞：blocking：调用结果返回之前，调用者被挂起；闲等
>
> 非阻塞：nonblocking，调用结果返回之前，调用者不会被挂起；忙等

一次文件io请求，都会有两阶段组成

> 第一步：等待数据，即数据从磁盘到内核内存
>
> 第二部：复制数据，即数据从内核内存到进程内存

阻塞型io：进程发起IO请求后，等待对方返回消息（同步），第一步等待数据时，进程处于阻塞状态，第二部复制数据时，进程也处于阻塞状态。

非阻塞性IO：进程发起IO请求后等待对方返回消息（同步），第一步是非阻塞状态，第二部是阻塞状态的！

复用型IO：进程调用内核中的IO复用器，能够监控多路IO，如磁盘io和键盘io，阻塞在多路io上，任何一路io请求，都能将进程唤醒，

io复用器

> select() 系统调用，能够最多同时监控1024路IO
>
> poll() 另外一种实现，unix贝尔实验室开发，前者是BSD开发

信号驱动型IO：进程发起IO请求后，不等待返回结果，给对方留一个回调接口，继续干别的事，第一段完成后，调回进程，第二段过程还是处于阻塞状态。这就是http的event模型

> event-driven
>
> epoll(Linux)：libevent
>
> Kqueue(BSD)：
>
> /dev/poll（Solaris）

异步IO：第一步和第二部都不阻塞，由内核一切全权完成