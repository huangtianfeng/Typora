[TOC]

# bash的配置文件

用户登录系统后，会启动一个接口程序，也称shell程序，一般默认是bash，而这个程序的启动，需要读取配置文件，完成环境的配置，以便用户在该接口程序下方便的执行一系列操作

## 配置文件的种类

根据配置文件中定义的内容，将配置文件分为两大类

###  profile类：

用于定义环境变量，启动需要执行的命令或者脚本

* /etc/profile： 全局设置

* /etc/profile.d/*.sh：也是全局设置，该目录下的所有文件，被/etc/profile配置文件中的代码读取，实现配置文件的模块化，在linux中，许多程序的配置文件都采用了此行是，便于管理，以下是/etc/profile文件中的一段代码片段，意思是遍历/etc/profile.d目录下的所有以sh结尾的文件，并source重载

  >for i in /etc/profile.d/*.sh ; do
  >    if [ -r "$i" ]; then
  >        if [ "${-#*i}" != "$-" ]; then
  >            . "$i"
  >        else
  >            . "$i" >/dev/null 2>&1
  >        fi
  >    fi
  >done

* ~/.bash_profile: 个人设置

### bashrc类

用于定义命令别名等其他设置

* /etc/bashrc：全局设置
* ~/.bashrc：个人设置

## 配置文件的加载顺序

加载顺序，根据不同形式的登录，各有不同

### 交互式登录

所谓交互式登录，是指用户通过各终端输入用户名密码的方式登录，或者以su - 命令的方式登录系统

顺序：/etc/profile-->/etc/profile.d/*.sh-->/.bash_profile-->~/.bashrc-->/etc/bashrc

所以，交互式登录时，bash的所有环境配置，都将重置

### 非交互式登录

所谓费交互式登录，指的是，用户通过图形界面打开的终端，或者以su命令（注意，这里没有“-”）切换的用户登录，以及在命令行中打开的子shell程序！

顺序：~/.bashrc-->/etc/bashrc-->/etc/profile.d/*.sh

也就是说，非交互式登录，只加载了个人配置文件和一部分定义在/etc/profile.d目录下的配置文件，并没有重置所有全局设置！当然，这并不意味着，/etc/profile中定义的内容就会失效，它是全局设置，在系统启动时，其配置文件中定义的内容，例如环境变量等，就保存在内核中，对所有用户都生效！只是非交互式启动时，不会重载该配置文件。例如，PATH环境变量时在/etc/profile文件中定义的， 如果你在系统启动后，手动更改了PATH环境变量的值，那么非交互式登录的时候，你修改的环境变量不会变！ 而交互式登录的时候，你修改过得PATH环境变量，将被初始化

如果我们想定义一个对所有用户都生效的命令别名，可以在/etc/bashrc文件中，添加一行

> alias cl=clear

之后，所有用户登录后，都可以使用cl命令来清理屏幕，方便了很多！

当然也可以在你自己用户的家目录中，根据自己的习惯，自定义仅对自己生效的别名，以方便在自己在日常工作中，更加方便快捷，更加有效率的执行命令，完成任务！

---

# shell脚本编程

什么是bash脚本？

bash脚本，就是命令的堆积！ 

所以，写好bash脚本，就需要我们熟悉各种命令的使用！ 而后通过脚本语言的逻辑控制，选择分支等一系列语法，将其组织成一个可自动化运行的命令集合！ 这就是脚本

怎么写？

直接用任意文本编辑器，顶格使用#！/bin/bash 注明需要使用到的解释器，然后按照特定的语法格式，编辑命令即可！当然，#!/bin/bash这一行其实不是必须的，如果不加这一行，我们在执行该文件的时候，也可以使用bash命令调用bash解释器执行该文件也是可以的！

怎么执行？

1. 给文件添加执行权限，然后直接使用绝对路径或者相对路径执行即可（和执行命令一样），如果想直接使用脚本名执行，可以将脚本所在位置加入到PATH环境变量中，就可以了

2. 使用bash命令来执行，可以不需要执行权限！它的本质是将脚本文件当做一个参数，传递给bash命令，而后由其解释执行！

   

## 常用测试条件及控制语句

对于脚本来说，简单的按顺序执行命令，当然是不够的！ 和许多编程语言一样，我们需要对命令的执行顺序加以控制才行，而想要控制，就避不开条件测试了！接下来我们首先看看条件测试，然后再将控制语句

### 条件测试语句

判断一个条件是否满足需求，我们使用一个测试表达式，然后由测试机制来判断该表达式是否满足！

#### 测试表达式的4种语法！

1. test EXPRESSION

2. [[ EXPRSSION ]]

3. [ EXPRESSION ]

4. command的执行状态结果

   注意，带中括号的条件表达式，两端都必须要有空格

   **每个测试表达式，有且只有两种结果，要么为真，要么为假，不存在中间值**

#### bash的测试类型

##### 数值测试：

> -eq	是否等于
>
> -ne	是否不等于
>
> -gt	是否大于
>
> -ge	是否大于等于
>
> -lt	是否小于
>
> -le	是否小于等于

##### 字符串测试

> ==	是否等于
>
> \>	是否大于
>
> <	是否小于
>
> ！=	是否不等于
>
> =~	左侧的字符串是否被右侧的patter所匹配
>
> -z “string”	判断指定的字符创是否为空
>
> -n “string”	判断指定的字符串是否不空

**注意**

1. 字符创比较尽量定义在双括号中
2. 比较对象是变量时，最好加双引号（变量为空时，该测试会出现问题）

##### 文件存在性测试

> -a FILE/-e FILE	文件是否存在
>
> -b FILE	文件是否存在，且为块设备文件
>
> -c FILE	文件是否存在，且为字符设备
>
> -d FILE	文件是否存在，且为目录文件
>
> -f FILE	文件是否存在，且为普通文件
>
> -h/-l FILE	是否存在，且为符号链接
>
> -p FILE	是否存在，且为命名管道文件
>
> -S FILE	是否存在，且为套接字文件

##### 文件权限测试

> -r FILE	是否存在，且对当前用户可读
>
> -w FILE	是否存在，且对当前用户可写
>
> -x FILE	是否存在，且对当前用户可执行
>
> -g FILE	是否存在，且拥有sgid权限
>
> -u FILE	是否存在，且拥有suid权限
>
> -k FILE	是否存在，且拥有sticky权限

##### 双目测试

> FILE1 -ef  FILE2	file1与file2是否为指向同一个文件系统的相同inode的硬链接
>
> FILE1 -ne FILE2	file1是否新于file2
>
> FILE1 -ot FILE2	file1是否旧于file2

##### 其他文件测试

文件是否有内容： -s FILE

当前用户是否为文件的属主：-O FILE

当前用户是否属于文件的属组：-G FILE

文件紫铜上一次读操作后，是否被修改过：-N FILE

##### 组合测试条件

逻辑运算

* 命令的逻辑运算

  COMMAND1 && COMMAND2

  COMMAND1 || COMMAND2

  !COMMAND

* 表达式的逻辑运算

  EXPRESSION1 -a EXPRESSION2

  EXPRESSION1 -o EXPRESSION2

  !EXPRESSION

  与或非就不再多解释了！

### 控制语句

##### if选择执行语句

* 单分支

  > if 测试条件; then(then独立成行是，测试条件后可以不用分号）
  >
  > ​                代码分支
  >
  >   fi

  例如：测试/tmp目录下是否有test文件，如果有则告知用户，已存在

  ```shell
  if [[ -a /tmp/test ]];then
  	echo "test is existing"
  fi
  ```

  

* 双分支

  > if 测试条件; then
  >
  > ​                条件为真时执行的分支
  >
  > ​            else
  >
  > ​                条件为假时执行的分支
  >
  > ​            fi

  例如:检查/tmp目录下是否有名为test的普通文件，没有则创建

  ```shell
  if [[ -f /tmp/test ]];then
  	echo "test is existing"
  	else
  		touch /tmp/test
  fi
  ```

  

* 多分支

  > if 测试条件1；then
  >
  > ​		条件1为真时执行的分支
  >
  > ​	elif 测试条件2；then
  >
  > ​		条件2为真时执行的分支
  >
  > ​	……
  >
  > ​	else
  >
  > ​		上述条件都不满足时的执行分支
  >
  > fi

##### case选择语句

语法：

>case $varaible in 
>
>PAT1)
>
>分支1;;
>
>PAT2)
>
>分支2;;
>
>……
>
>*）	这里表示都匹配不到时，执行该分支
>
>分支n;;
>
>esac

**注意**：

case支持glob风格的通配符

每个分支后必须用双分号结尾，可以单独成行，也可以在分支后面

##### while循环语句

语法：

> while CONDITION ；do
>
> 循环体
>
> 循环控制变量的修正表达式
>
> done
>
> 
>
> 进入条件：CONDITION测试为真
>
> 退出条件：condition测试为假

高级用法：

> while read VARIABLE； do
>
> 循环体
>
> done < /path/from/somefile
>
> 
>
> 依次读取/path/from/somefile文件中的每一行，且将其复制给VARIABLE变量：

##### until循环

语法：

> until CONDITION ；do
>
> 循环体
>
> 循环控制变量的修正表达式
>
> done
>
> 
>
> 进入条件：CONDITION测试为假
>
> 退出条件：condition测试为真

##### for循环

语法：

> for VARAIBLE in LIST；do
>
> 循环表
>
> done
>
> 注意：列表很大时，for循环效率很低，因为列表中的数都需要保存在内存中

高级用法：

> for ((控制变量初始化；条件判断表达式；控制变量的修正表达式；));do
>
> 循环体
>
> done

##### 循环控制语句

* continue：提前结束本轮循环，而直接进入下一轮循环的条件测试

* break：提前结束循环

##### 脚本实例

编写脚本，实现自动创建三个用户，并计算该三个用户的uid之和

```shell
/bin/bash
name=test
sum=0
for (( i=0,j=1;i<3; ));do
        useradd ${name}$j &> /dev/null
        if [[ $? -eq 0 ]];then
                let sum+=$(grep ${name}${j} /etc/passwd| cut -d: -f3)
                let i++
                let j++
        else let j++
        fi
done
echo sum=$sum

```

## shell脚本的参数传递

我们在执行命令的时候，会在一个命令后面加上很多参数，以达到不同的目的，这个参数，是怎么传递给程序的呢？

执行脚本和执行命令一样，在脚本后加上多个参数，用空格隔开即可，例如

>   myscript.sh argu1 argu2 ……

而引用，也很简单，我们只需要在脚本中，使用变量$1,$2…………

**注意：shell脚本中，还有些许特殊变量**

* $0：表示该脚本的文件名
* $#：表示传递给脚本的参数总和
* #*：引用所有参数，但是将各参数当做独立的字符串
* $@：引用所有参数，但是将各参数当做一个整体，单个字符串

shift [n]： 该语句可以实现踢掉n个参数，默认踢掉一个

​	例如：当执行脚本myscript.sh时，传递两个参数，tom，Jerry，当程序中出现一个shift语句时，程序会将tom这个参数剔除，原本使用$1会引用tom的，踢掉之后，$1将引用Jerry

## shell脚本的用户交互

通过键盘输入数据，完成变量赋值操作

 read[option] [name...]

​                           -p“提示字符”

​                            -t #  限定输入时间

## shell脚本的语法检测

* bash -n FILE，智能检测出语法错误，不能检测出逻辑错误
* bash -x FILE    调试执行

