[TOC]

# 进程管理

## 相关概念

进程：是一个执行中的程序文件的一个的副本，意思就是，同一个程序文件，可以发起为多个进程！

调用（call）：所谓调用，就是调用别人事先编写好的函数或者功能模块

系统调用发生在内核空间中，库调用发生在用户空间，库调用可能是系统调用的二次封装，也可能是独立的功能模块

cpu上的指令分为两类，普通指令（环3上的指令）和特权指令（环0上的指令），特权指令主要完成硬件的管理工作，决不允许程序自己随意调用，除了内核。 如果某个程序需要用到特权指令，就需要向内核发起系统调用

每一个程序的执行流程，都是自上而下的顺序选择执行的，将指令放到CPU上执行，如果应用程序需要完成特权操作时，就直接调用内核提供的系统调用，接下来程序本身就停下来了，等待内核将你调用的功能放到CPU上执行，调用返回后，程序再继续运行，所以整个代码执行过程中，会在执行用户代码和执行内核代码这两者之间不停转换（称之为模式切换），而进程终止的时候，称之为软中断，运行用户代码的时候，表示整个操作系统运行在用户模式（用户空间）下，一旦发起系统调用，整个操作系统就运行在内核模式下（内核空间）

linux是一个多任务的操作系统，当CPU只有一个的时候，进程又有多个的时候，内核就负责对CPU的资源进行时间分片，以及对进程实现调度，根据进程的优先级，将进程轮流调度到CPU上执行，内核还要负责将每个进程保存于CPU寄存器中的中间信息（当前状态）保存下来，这个过程叫保存现场，而对应的调度之前的进程到CPU中执行时，就需要恢复现场，这个样的切换过程，每一次切换都需要执行一段内核代码

每个进程的中间信息（元数据），结构都差不多，所以内核为进程创建一个结构体，这个结构体叫task struct，每个进程的中间信息都存储于一个结构体中，而存储位置不连续时，为了便于寻找，基于链表存储，多个任务的task struct组成的链表，称之为task list。

进程内存：进程是不可能直接访问硬件的，所以进程的内存空间都是虚拟内存空间，所谓虚拟内存空间，是内核会为每一个进程虚拟出一个理想的运行环境，告诉它，在我心里，只有你一个进程，所有内存资源都是你的。

内核将内存划分为一个个小的单元，一般来说，这个单元的固定大小为4K，而称这个单元为Page Frame：页框，用于存储页面数据，所谓页面数据，就是能够存在页框中的数据，就是页面数据，存储Page。而进程不断的创建和销毁，会造成内存中出现大量分散的Page Frame，所以，内核还负责将其组织成为线性的连续的内存空间提供给新的进程，这就是所谓的线性内存空间！

任何进程想摆脱内核的控制，就意味着要去运行特权指令了，而运行特权指令，会触发软中断，cpu会立即唤醒内核，内核将接管一切！（没有漏洞的情况）

进程优先级：分为140个级别：
>1-99：实时优先级：很少手动处理
>100-139：静态优先级：数字越小，优先级越高
>Nice值：-20-+19，分别对应于100-139这个范围
>
>内核为了加快调度速度，将进程队列分为140个，每个优先级，放在一个队列中，所以，每次调度，只需要扫描着140个队列中的第一个进程，每个队列都有两个，一个运行队列，一个过期队列，运行过的进程就被放置在过期队列中，当运行队列运行完毕后，过期队列切换为运行队列，运行队列切换为过期队列，然后重复执行操作

### 进程创建

init负责一切用户空间的进程管理

对linux系统来讲，进程存在所谓的父子关系，父子关系保存于task struct中

进程都由其父进程创建，父进程通过fork()系统调用，fork自身，当子进程需要修改进程数据时，通过写实复制（CoW）机制，创建出一段新的内存空间，该内存空间即为子进程