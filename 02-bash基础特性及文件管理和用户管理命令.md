[TOC]

# 文件管理相关命令

## 常用的文件管理命令

* mkdir命令 ：创建目录

  语法：mkdir [option] dirname

  常用选项：

  -m 指定目录的权限

  -p 递归创建（如果路径不存在，按需创建所需的父目录）

  -v 显示创建过程

* rmdir命令：删除空目录

  语法： rmdir [opton] dirname

  常用选项：

  -p： 递归删除，如果删除一个空目录后，会导致其父目录成为空目录，那么将其父目录一并删除

  -v：显示删除过程

* touch命令：修改文件时间戳，也常用来创建新普通文件

  语法：touch [option] file

  常用选项：

  -c：当指定文件不存在时，不会创建新文件

  -a 修改更新access time

  -m 修改更新modification time 

  -t： 配合前面两个选项使用，指定时间

  > 时间的格式为：[[CC]YY]MMDDhhmm[.ss]
  >
  > 如果不使用-t指定时间，那么-a，-m选项，会将时间戳更新为当前时间

  -r：后接一个参考文件，将时间戳修改为参考文件的时间戳

* cp命令：复制文件

  1. 单源普通文件复制：cp [option] 源文件 目标文件

     目标文件存在且为普通文件时，覆盖之

     目标文件不存在时，创建之

     目标文件是目录时，在该目录下创建一个同名文件，并复制数据流

  2. 多源普通文件复制：cp [option] 源文件 目标文件

     目标文件只能是已存在的目录，在目标目录下创建同名文件，并复制数据流

  3. 单源目录复制 cp -r 源文件 目标文件

     目标文件只能是目录，如果存在，则在目录下创建一个和源文件同名的子目录，并复制数据流

     如果不存在，则创建同目标文件名相同的目录至该位置

  4. 多源目录复制：cp -r 源文件 目标文件

     目标文件只能是已存在目录

  常用选项：

  -i：交互式复制，当需要覆盖时，需要确认

  -f：强制复制

  -d：复制符号链接时，复制符号链接本身，默认是复制其指向的内容

  -r或者-R：递归复制目录

  -a：相当于-dR：用于归档或备份

  --preserv=：指定保留的元数据

  > mode	权限
  >
  > owneship	属组
  >
  > context	selinux安全上文
  >
  > timestamps	时间戳
  >
  > xattr	特殊权限
  >
  > links	链接属性
  >
  > all	所有

* mv命令：移动或重命名文件

  在同一个目录下，移动文件即重命名

  用法和cp命令基本一致，不过移动目录的时候可以不用加-r选项，直接激动即可

* install命令：复制文件

  1. 单源复制：install 选项 源文件 目标文件

  2. 多源复制：install 选项 源文件…… 目标文件

     ​			install -t 目标目录 源文件

  3. 创建目录：install -d 目录名

  常用选项：

  -m 指定高目标文件权限，默认为755

  -o 指定目标文件属主

  -g 指定目标文件数组

* mktemp 命令：创建临时文件

  语法：mktemp 选项 模板

  例如：mktemp test.XXXX

  -d：创建临时目录

  该命令穿件完成后会直接输出文件名，所以可以使用命令引用给变量赋值

* rm命令：删除文件

  这个命令，曾经让人闻风丧胆，因为centos6.0以下的版本，使用rm -rf /命令是没有警告，可以直接执行的，这意味着什么呢……我就不说了

   -i  交互式删除

  -f 强制删除

  -r 递归删除目录

## 常用的文件内容查看命令

* cat和tac命令，正序和逆序查看文件内容，可一次查看多个文件

  语法：cat 选项 文件名

  常用选项：

  -n 对查看的内容同一编号

  -E 显示行结尾的结尾符

* more

  分屏查看，特点是翻到文件末尾时，会自动退出

* less

  分屏查看，q退出（man命令就是调用的这个命令显示的）

* head

  默认查看文件前十行

  -n # 或者 -# 指定查看文件前#行

* tail

  默认查看文件末尾十行

  -n #或者-# 指定产看文件末尾#行

  -f 显示完内容后不退出，而是动态产看文件末尾的变动

## 其他常用基础命令

* pwd命令：显示当前工作路径

* cd命令：切换工作目录

  不加参数，则切换至当前 用户家目录

  .	表示当前目录

  ..	表示当前目录的父目录

  \- 	可以在当前目录和上一次所在目录之间来回切换

  ~ 	后接一个用户名，可以切换至指定用户的家目录中

* ls：文件显示命令

  -a：显示所有文件，包括以.开头的隐藏文件

  -A：显示除了.和..两个目录之外的所有文件

  -l：以长格式显示文件信息,格式如下

  > 文件类型，文件权限，inode计数，属主，属组，文件大小单位为字节，文件最近一次被修改的时间，文件名

  -h：单位转换， 转换后，精度会有所丢失

  -d ：显示目录本身的属性，单独用没意义，通常结合-l选项

  -r：逆序显示

  -R：递归显示目录下的文件， 子目录都会被展开

* file：查看文件内容类型（不是文件类型）

* type：查看命令类型（linux命令分为内嵌命令和外部命令）

* echo：回显命令

  -e：使转义符生效，例如：\n

  -n：不自动打印换行符

* shutdown：关机命令

  语法：shutdown 选项 时间 通知信息

  常用选项：

  -h 关机

  -r 重启

  -c 取消之前设置的管理操作

  -k 只打雷不下雨，逗你玩

  时间格式：

  now：现在，立刻，马上

  hh:mm：指明时间点

  +#：多少分钟后

* date：调整和显示系统时钟

  date [OPTION]... [+FORMAT]

  格式符：

  %F 年月日

  %T 时分秒

  %c 年月日周时分秒

  %Y 年

  %m月

  %d 日

  %H 时

  %M分

  %S秒

  %s  从70年零点到当前时间的秒数

  设定时间，使用date 月日时分年（两位四位均可）.秒

  秒和年可省略，年默认为当前年，秒默认为零

* clock（hwclock）调整和显示硬件时钟

  -s hctosys  将系统时钟同步为和硬件时钟

  -w systohc 将硬件时钟同步为系统时钟

  默认不加选项显示系统时钟

* ntpdate：时间同步命令

  ntpdate **-u** time.windows.com #网络时间同步命令

  注意：若不加上-u参数， 会出现以下提示：**no server suitable for synchronization found**

  -u：从man ntpdate中可以看出-u参数可以越过防火墙与主机同步；

  

  **ntp常用服务器**：

  中国国家授时中心：210.72.145.44
  NTP服务器(上海) ：ntp.api.bz

*  who命令

  显示已登录的用户以及相关信息，包括 ID、终端、上线时间、CPU 使用量、正在执行的任务等

  -b  查看系统最近一次启动的时间

  -r 查看运行级别

* whereis  查找命令，使用手册路径

  -b 仅查找二进制程序文件路径

  -m 仅查找使用手册路径

* w   

   who的增强版，能查看到资源使用情况

* which：在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果

  --skip-alias：忽略别名

* alias

  直接执行显示当前系统中的所有别名

  alias 别名=命令名	创建别名

  unalias 别名	取消别名

* tree命令

  查看目录的层级结构

  -L 指定显示多少级的层级结构，而不是显示所有

## 元数据

* 什么是元数据？

  所谓元数据，就是一个文件的索引信息或者说是描述信息，它记录的不是文件的具体内容，而是文件的各种属性描述，其中包括，文件权限，文件属主，三个时间戳（最近读取时间，最近改动时间和最近修改时间），被链接数，以及最重要的数据块指正，该指正指明真正的文件内容存储在磁盘的哪个位置！

* 如何查看元数据？

  使用stat命令，后指明要查看的文件路径即可！

时间戳：

access time：最近被读取的时间

modification time：最近改动文件内容的时间

change time：最近改动文件元数据的时间

至于如何修改他们，前面已经结果过touch命令了，这就就不再重复，只是需要注意的是，change time这个时间是不能手动修改的，它会随着文件内容的改动，以及其他文件元数据被改动是（这里不包括读取文件atime变动），一同更新

# 用户及用户组详解及其常用命令

linux是一个多用户的操作系统，顾名思义，linux允许同一个系统上，存在许多不同的用户，不像我们的手机一样，一般都只有你自己使用，只需要输入开机密码，或者解锁密码，就能登录，而后里边的所有文件都你都能操作！

在linux系统中，有用户和用户组的概念，它的作用是方便基于用户和用户组，配置不同的权限，来管理各用户所能访问的资源！

### 用户

用户一般分为三种，分别是root用户，系统用户，和普通用户

其中root用户，是至高无上的，它的权限大到能够自杀，所以，一般情况下，是不介意使用root用户直接登录系统的，因为人不是神，难免有犯错，有失误，有大意的时候，比如，最被人津津乐道的“从删库到跑路” 就是因为人大意，加上权限太高，导致的误操作！

* 系统用户

  因为在服务器启动时，会有许多守护进程需要启动，但是，一个进程的启动，势必需要一个用户来发起，该进程会成为这个用户的代理，拥有该用户的权限（所以，不能是root用户，前面说了，root用户的权限是很吓人的）那么在系统启动之初，各个应用程序，就应该需要由那么一个用户启动，这个用户不需要登录系统，只需要在开机时，让进程以它的身份发起就ok了，这个用户，我们就称之为系统用户，系统用户，一般会在我们安装对应的服务时，通过程序脚本自行创建！ 无需我们手动添加！

  对于centos6以下来说，系统用户的uid为1-499，对于centos7来说，系统用户的uid为1-999

* 普通用户：

  这个就没什么好介绍的了，能够登录系统，进行各种操作，利用计算机资源的用户，就是普通用户了！

* /etc/passwd和/etc/shadow文件

  这个两个文件，存放着我们用户的相关信息！简单介绍一下！

  1. /etc/passwd文件内容

     > root​ ​:x :​0:0:root:/root:/bin/bash
     >
     > tian​:x :​1000:1000:tian:/home/tian:/bin/bash

     该文件以冒号为分隔符，分为七个字段，他们代表的意义分别是：

     用户名：用户密码：用户uid：用户主组id号：注释信息：家目录路径：默认shell类型

  2. /etc/shadow文件内容

     ```
     root:$6$qXb4lJOVR0iLp4H/$2sEmJLQ5wAkeM4PJi/89bN7xC6MgDJDfLXmGXXAVY9tu9UtMuFs133UdKoH/A8He1Fgy9tFDW/vAyMtOCawrt.::0:99999:7:::
     tian:$6$/.eBbDQAGWEfWiVP$GVHeIuOqNy9FBG546p7mTU5GTk53QXPxgVBRDSD1jO5OvoKTQ0szx9Kawar0rDDbR2NLdb0jAmUdMLUu2ai6G/::0:99999:7:::
     
     ```

     该文件也是以冒号为分隔符，分为八个字段，分别表示为

     用户名：加密的密码：最近一次修改密码的时间（从70年到当下的天数）：密码最短使用期限：密码最长使用期限：警告期限：过期期限：保留字段

### 用户组

每个用户，都有一个主组，并且同时可以有多个附加组！

那么组，有什么用呢？其实组的作用，也就是为了更加方便的进行权限管理

加入，我们想新建一个文件，该文件只允许user1，user2，user3用户进行读写执行操作，其他人都不能访问！ 如果是基于用户来进行权限管理，是一件很麻烦的事（可以通过acl访问控制列表实现）！ 而有了组的功能后，我们可以创建一个文件，将其属组改成group1,而后，将user1，user2，user3都添加到group1中，然后将文件的属组权限，修改为rwx，其他用户权限设置为0即可！  往后如果还想加入某些其他用户，也只需要将其加入到group1组中，就可以对该文件进行操作了

用户组也有group文件和gshadow文件

* /etc/group

  > bin:x :​1:bin,daemon
  >
  > 组名：密码：组id：组成员列表

* /etc/gpasswd

  > haldaemon:!::haldaemon
  >
  > 组名：密码：管理员：组成员列表

### 权限

linux系统中，每个文件，每个目录都有一组权限！ 使用ls -l命令即可看到！  

第一段内容，就是我们的权限位，这个权限位包含了十个字符！ 例如

-rw-r-----. 1 root root 1370 3月   1 12:17 /etc/passwd

-rwsr-xr-x. 1 root root 27832 6月  10 2014 /bin/passwd

**第一个字段**，第一个字符表示该文件的类型，-表示普通文件，d表示目录文件，c表示字符设备文件，b表示块设备文件，l表示链接文件，s表示套接字文件，p表示管道文件……

而后的九个字符，每三个字符表示一组权限，他们分别是属主，属组，和其他人的权限，而每一组中，r（第一位）表示读，（第二位）w表示写，x（第三位）表示执行，每个对应的位置上，如果有字符，则表示有该权限，-表示无权限！  上面例子中，就表示，属主有rw权限，属组有r权限，其他人没有任何权限！

**第二个字段**，一个数字，表示该文件被链接的次数

**第三个字段和第四个字段** 表示该文件的属主和属组

**第五个字段** 表示该文件的大小，单位为字节！

**第六个字段** 表示该文件的最近更改时间（mtime）

**第七个字段** 文件完整路径

**这个要背熟了**

 第一字段的第一组权标，表示属主拥有的权限，第二组权限，表示属组拥有的权限，第三组权限，表示其他任何人拥有的权限！

当一个程序或者一个用户访问一个文件时，系统首先判断该用户是不是文件的属主，如果是，则匹配属主的权限，如果不是，则判断该用户的属组，或者附加组有没有包含文件的属组，如果是，则匹配属组的权限，否则匹配其他人的权限！

对于普通文件而言， r权限，表示可查看文件内容，w权限，表示允许修改文件内容，x权限，表示是否可以执行该文件，对于普通文件而言，x权限是很危险的，我们知道，计算机只能识别二进制的格式，而一个文件，如果是文本文件，执行它，可能会发生未知的错误！

对于目录而言：r权限，表示可以查看该目录下有那些文件，仅能查看文件名

w权限，以为这，可以修改该目录下的结构，所以，如果一个用户想删除一个文件，必须对该文件的父目录具备w权限才行

x权限，表示可以cd ，切换到该目录先，将其作为工作路径

#### 特殊权限位

linux文件还有三个特殊权限，SUID,SGID,SBIT,他们分别用s，s，t三个字母，在文件的属主，属组，和其他人权限位的执行权限位置显示！ 如果文件原本有x权限，那么这组权限的字母将用大写表示！

SUID权限仅能对二进制程序设置：它标识，无论任何人，执行该程序时，都将以该程序属主的身份运行

SGID权限：仅对目录设置，它标识，任何对该目录有写权限的人，在该目录下创建的新文件的属主将继承该目录的属主

SDIT权限：仅对目录有效，它标识，任何人在该目录下创建的文件（有权限的情况下），只有用户自己和root用户能将该文件删除！

* umask：文件创建的权限掩码！  设定了创建文件时的默认权限！

  创建目录时，使用777-掩码值

  创建文件时：使用666-掩码值

  对于普通文件来说，拥有执行权限是一件很危险的事情，所以定义文件的最大权限是666而不是777，  这就出现一个问题，加入掩码中存在执行权限，那么用666减去掩码后的值，将出现3或者5,这个值是不正确的，需要再减去 一个执行权限1，才是真正结果，希望大家能想通！

## 常用的用户（组）管理命令及权限管理命令

* useradd命令：创建新用户

  语法：useradd [options] [login]

  常用选项：

  -u 指明uid号

  -g  指明用户主组，该组必须已存在

  -G  指明用户的附加组

  -c 设置用户的注释信息

  -d 指定用户的家目录位置， 家目录的创建是通过复制**/etc/skel**目录并重命名完成的， 当指定的家目录已存在， 则不会进行复制操作

  -s 指明默认shell

  -r 创建系统用户

  -N 不创建同名用户组，而是使用-g指定的组，如果没用-g指定，那么默认组有/etc/defaults/useradd中的GROUP变量定义

  注意，添加用户的许多默认设置都在/etc/log.defs文件中，例如gid范围，uid范围，创建的邮箱路径等等等等

  -D： 显示创建用户的默认信息（该默认信息在/etc/defaults/useradd文件中）可自行查看修改，也可以用-D 配合其他选项修改对应信息

  -D -b 修改新用户家用户的路径前缀（文件中的HOME变量）

  -D -e 指定经用此用户账户的日期（文件中EXPIRE变量）

  -D -f 密码过期到账户被禁用之前的天数（文件中的INACTIVE变量）

  -D -g 新用户的初始组的组名或id（当使用-N选项时，这个默认值才生效，指定的gid必须存在）

  -D -s 新用户的默认shell (文件中的SHELL变量)

  **在这里使用-D 修改后的内容，将被直接保存到文件中，重启后依旧生效**

  示例：创建用户tom,指定UID为5001，指定家目录为/tmp/tom, 指定shell为/bin/zsh, 指定基本组为tom，附加组为jack

  > useradd -u 5001  -d /tmp/tom -s /bin/zsh -g tom -G jack tom

* userdel命令：删除用户

  语法：userdel [option] login

  常用选项：

  -r：连同用户家目录一起删除，默认情况是会保留有用户家目录的

  -f：强制删除用户，及时用户已经登录系统

  示例：删除用户test1，连同用户家目录一起删除

  > userdel -rf test

* usermod命令：修改用户属性

  语法：usermod [option] login

  常用选项：

  -u：修改用户uid号

  -g：修改用户基本组，修改完后，家目录中的文件数组会 一同改变，但是其他目录下的，需要手动修改

  -G：覆盖修改用户附加组，意思是原先已经存在的附加组将被覆盖，如果不想被覆盖，可以在该选项后，加-a 表示追加附加组

  -d：修改用户家目录

  ​	还可跟-m选项（该选项只能和-d一同使用），表示将原有的家目录中的文件移动到新的家目录中

  -l：修改用户登录名

  -L：锁定用户密码

  -U：解锁用户密码

  示例：将用户tom的uid修改为4000，添加附加组 test1，将家目录修改为/tmp/tom目录

  > usermod -u 4000 -aG test1  -md /tmp/tom tom

* passwd：修改设置用户密码

  常用选项：

  -i DAYS 非活动期限

  -e DATA 过期时间

  -n DAYS密码最短使用期限

  -x DAYS密码最长使用期限

  -w DAYS警告期限

  --stdin  

  echo "PASSWD" | passwd --stdin USERNAME

  示例：将tom用户的密码更新为passwd

  > echo passwd | passswd -stdin tom

* groupadd命令：添加用户组

  语法：group [option] groupname

  常用选项：

  -g：指明组id号

  -r：创建系统组

* groupdel命令：删除组

* groupmod命令：

  -g：修改组id号

  -n 修改组名

* gpasswd命令：设置组密码和管理组

  -a：向组中添加用户

  -d：从组中删除用户

  -r：移除组密码

  -A：设置组管理员列表

  -M：设置组成员列表

  不加选项表示给组设置密码

* newgrp命令：新建一个子shell，并将当前用户的主组切换为指定组

  前提是，知道要切换的组的组密码（不要求当前用户在这个组成员列表中） 如果是在一个组的成员列表中，那么将其切换为主组不需要输入密码

* chown命令：修改文件属主和属组

  语法：chown [option] FILE

  一般用法chwon 属主[:属组] FILE

  文件属主属组可以同时修改，也可以单独修改！

* chmod命令：修改文件权限

  语法：chmod MODE FILE

  权限可以有多种表示方法：

  赋权表示法：u=，g=，o=，a= 用逗号隔开即可

  授权表示法：u+，g+，o+，a+

  注意：特殊权限一样可以通过该命令修改，SUID,SGID,STID分别用s，s，d表示，u+s表示添加SUID，g+s表示添加SGID，o+t表示添加STID权限

  八进制表示法：0666

  -R：对目录进行递归权限修改

  --reference=：以指定模板文件进行权限更新

### 权限的八进制表示法介绍

一般，一组完整的权限中，有rwx三个权限，没一个位置有两种变化，所以，三个位置，一共有八种变化，我们便用八进制数来表示，他们的对应关系如下所示

| 权限位 | 八进制数 |
| ------ | -------- |
| ---    | 0        |
| --x    | 1        |
| -w-    | 2        |
| -wx    | 3        |
| r--    | 4        |
| r-x    | 5        |
| rw-    | 6        |
| rwx    | 7        |

没个文件都包含三组三位的权限，所以，一个文件完整的权限是777

# bash基本特性

## 命令行展开机制

在bash中，{} 能承载一个以逗号分隔的路径列表，展开为多个路径 例如可以将/tmp/{a,b,c}展开成为/tmp/a,/tmp/b和/tmp/c，花括号可以嵌套使用

* 示例：使用该特性，创建目录/tmp/a1, /tmp/a2, /tmp/a1/a, /tmp/a1/b，以及在tmp下创建目录x_y, x_z, q_y, q_z

  > mkdir /tmp/{a1/{a,b},a2}
  >
  > mkdir /tmp/{x,q}_{y,z}

  相当于乘法的结合律

## 命令历史功能

bash能记录用户输入的命令到内存中，并且在退出登录的同时，将其写入到用户家目录下的.bash_history文件中！

使用history命令可以查看当前内存中的历史命令

通过修改变量可以设定历史记录的特性

HISTSIZE:该变量值标识了呢村中最多保存多少条历史命令

HISTFILE：该变量定义了历史命令持久保存的位置

HISTFILESIZE：持久保存命令的最大值

* HISTCONTROL: 该值可以用来控制命令历史的记录方式

  ignoredups 表示忽略重复命令

  ignorespace 表示忽略空格开头的命令

  ignoreboth 表示以上两者都忽略

* history命令用法：

  -c：清空内存中的命令历史

  -d #：删除指定命令

  -r：将历史命令文件中的内容读取至内存

  -w：将内存中的命令写入到保存文件中

* 历史命令的引用方式：

  !# 表示再次执行第#号命令

  !!表示再次执行上一次命令，不过用箭头向上翻应该更为方便

  !string  向前追溯最近一条以该字符串开头的命令

  还可以使用快捷键esc加.   或者字符串!$来引用上一条命令的最后一个参数

## 命令别名

如果一个命令太长，又经常使用到，可以为其设置一个短小方便的别名

显示查看别名，使用alias命令

设置别名使用：alias 别名=原名（设置别名仅对当前shell有效），别名和原名相同时，源命令将被隐藏，在命令前加反斜线\即可执行原命令

取消别名：unalias 别名

## 命令补全（路径补全功能）

* 命令补全

  通过给定的命令打头字符串，依次在内嵌命令，PATH变量指定的路径下自左向右查找，如果有对应的命令唯一被标识，则直接补全，如果有多个，连敲两次列出列表

* 路径补全

  根据给出的路径，在对应路径搜索文件

## 命令执行状态结果

每一个命令，执行完毕后，都会有一个状态返回值，在linux中，可以使用echo $?即可查看，注意，该状态结果有时效性，仅在一条命令执行完毕后，下一条命令执行前有效！

0表示执行成功，非0表示执行失败

## 命令引用

在命令行中，使用$(COMMAND)或者'COMMAND'可以引用一个命令的执行结果（不是状态结果）

例如：在/tmp目录下创建以tfile开头，后跟当前日期和时间的文件，文件名形如：tfile-2016-05-27-09-32-22

> mkdir /tmp/tfile-$(date "+%Y-%m-%d-%H-%M-%S")

## 命令hash

所谓命令hash就是命令运行后将搜索到的路径缓存下来，下次执行时，就不需要再重新在环境变量的路径中去重新查找

hash命令可查看当前的hash表

-d 选项可删除某个命令的hash

-r 选项可删除所有hash

## 变量

所谓变量：就是一段命令的内存空间

shell脚本语言，属于弱类型语言，变量不需要提前声明，它将声明和定义两部合二为一，所以，在bash中，需要用到，自己定义一个变量名的同时，直接对其赋值就可以了，例如：nmae=tianfeng

在bash当中，变量分为

* 环境变量：在当前shell及其子shell当中有效

  环境变量的创建方式：

  export name=huangtianfeng

  先对变量赋值。而后export name 也可以

  declare -x name=huantianfeng

  也可以先复制后声明：

  

  查看环境变量的方式：declare -x    export     printenv    env

  撤销环境变量： unset name

* 本地变量：仅对当前shell有效

* 局部变量：仅对代码片段有效，通常在shell脚本中的函数中出现

在命令行中直接赋值的变量一般属于本地变量：

* declare的用法

  declare -r name：将name声明为只读变量

  declare -i name：将name声明为整型变量

* 变量引用：使用符号${name} 即可：{}不是必须的，大部分情况下可以省略 $name即可

  "" 弱引用，双引号中的$name会被替换成为变量值

  ‘’强引用，单引号中的$name不会被替换成变量值，直接显示字符串

## 命令行逻辑控制

短路法则：

命令1 && 命令2： 命令1执行失败，结果必为假，所以命令2将不再执行，命令1执行成功，结果取决于命令2的执行结果，命令2必须执行

命令1 || 命令2：命令1执行失败，结果取决于命令2，所以命令2必须执行，命令1执行成功，结果必为真，则命令2不再需要执行

## bash快捷键

ctrl+a 跳转至命令行首

ctrl+e 跳转至命令行尾部

ctrl+u 删除光标之前的所有字符串

ctrl+k 删除光标之后的所有字符串

ctrl+l 清屏

## golb文件名通配

所谓通配，表示用指定的符号，表示特殊的含义，和正则表达式一样的机制，只是支持的元字符有所区别

* 元字符：

  *任意长度任意字符

  ?单个任意字符

  [abc]或者[a-z] 匹配指定范围内的任意单个字符

  [＾] 匹配指定范围外的任意单个字符

  特殊格式

  [[:alpha:]]所有字母

  [[:alnum:]]所有字母和数字

  [[:digit:]]所有数字

  [[:upper:]]所有大写字母

  [[:lower:]]所有小写字母

  [[:punct]]所有标点符号

  [[:space:]]所有空白字符

举个栗子：

复制/etc目录下所有以p开头，以非数字结尾的文件或目录到/tmp/mytest1目录中。

> \cp -rf /etc/p\*\[^[:digit:]]   /tmp/mytest1

注意，这里我的命令前面使用了\ ，原因是在root用户下，cp命令是个别名，默认加了i选项，所以不加\ -f选项会失效，结果将导致如果有重复的，需要手动点确认覆盖

## io重定向和管道

所谓的io重定向，就是将一个命令的执行结果不输出到屏幕，传送给另外一个命令，当做该命令的输入，而后进行数据的处理

 标准输入 stdin，用数字0标识

标准输出 stdout，用数字1标识

错误输出 stderr，用数字2标识

一般，默认stdin为键盘，stdout和stderr都是屏幕

* 输出重定向符号：>，>>分别表示覆盖重定向和追加重定向，输出重定向可以指向/dev目录下的设备，这很危险，如果覆盖重定向至一个磁盘设备，将直接损坏mbr扇区

  将错误输出和标准输出重定向到同一个位置可以使用&>，&>>，也可以 >file 2>&1  意思是，将标准输出重定向到文件，而后将错误输出重定向至标准输出

  输入重定向符号：<

  还有一个特殊的符号<<   它可以这样用

  cat> 文件名<<EOF 以达到创建文件的目的

  这里的EOF代表结束符，可以替换成别的字符， 

* set -C 可以禁止覆盖输出重定向覆盖已存在的文件

  此时可以使用>|   来强行覆盖

  set +C 可取消此特性

* 管道符 |

  实现将前一个命令的输出送给后一个命令当做输入， 管道可以转发多层

  如果想既保存到某个文件中，又想显示到屏幕或者继续通过管道送往下一个命令， 那么可以使用**tee命令**，它能将接受到的内容，保存一份到指定文件中，而后输出到屏幕  一般用法

  command1 | tee /PATH/TO/SOMEFILE | command3